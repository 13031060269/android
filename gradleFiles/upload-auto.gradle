class MakeApk2Aar {
    boolean make
}

String cacheDir = buildDir.absolutePath + "/aar-cache"
file(cacheDir).mkdirs()
def ids = file("build/outputs/ids.txt").absolutePath
android.aaptOptions {
    additionalParameters "--emit-ids", ids
    failOnMissingConfigEntry false
}
boolean isApp = project.getPlugins().hasPlugin("com.android.application")
boolean isLib = project.getPlugins().hasPlugin("com.android.library")
if (isLib) {
    extensions.create("makeApk2Aar", MakeApk2Aar)
    apply plugin: 'maven'
}

afterEvaluate {
    String packageName = "package=\""
    String content = file(android.sourceSets.main.manifest.toString()).text
    int start = content.indexOf(packageName) + packageName.size()
    packageName = content.substring(start, content.indexOf("\"", start))
    String prefix = packageName.replace(".", "_") + "_"
    if (isLib) {
        int index = packageName.lastIndexOf(".")
        String group_id = packageName.substring(0, index)
        String artifact_id = packageName.substring(index + 1)
        String version_name = android.defaultConfig.versionName
        uploadArchives {
            repositories {
                mavenDeployer {
                    repository(url: uri("$MVN_STORE"))
                    pom.project {
                        name "lwp"
                        version version_name
                        artifactId artifact_id
                        groupId group_id
                        packaging "aar"
                        description "这是一个aar！"
                    }
                }
            }
        }

        tasks.findByName("bundleReleaseAar")?.doLast {
            if (!makeApk2Aar.make) {
                return
            }
            makePublicXml(file(cacheDir + "/apkres/values/${prefix}public.xml"), file(ids))
            File aar = outputs.files.files.first()
            copy {
                from zipTree(aar)
                into cacheDir
            }

            File cache = file(cacheDir)
            clearEmpty(cache)
            aar.delete()
            String path = "${cacheDir}/classes"
//            "jar  -cf ${path}.jar -C ${path} /".execute().waitFor()
            file(path).deleteDir()
            "jar  -cf ${aar.absolutePath} -C $cacheDir /".execute().waitFor()
        }
    } else if (isApp) {
        tasks.findByName("mergeReleaseResources")?.doLast {
            file(cacheDir).deleteDir()
            copy {
                from outputs.files.files
                include "merged.dir/**", "compile-file-map.properties"
                exclude "*/*.json"
                into cacheDir + "/apkres"
                rename("values", prefix + "values")
            }
            File merged = file(cacheDir + "/apkres/merged.dir")
            fileTree(merged).each { file ->
                copy {
                    from file
                    into cacheDir + "/apkres/" + file.parentFile.name
                }
            }
            merged.deleteDir()
            file("$cacheDir/apkres/compile-file-map.properties").readLines().each {
                File resFile = file(it.split("=")[0])
                copy {
                    from resFile
                    into cacheDir + "/apkres/" + resFile.parentFile.name
                }
            }
        }
        tasks.findByName("processReleaseResources")?.doLast {
            File ap_ = fileTree(resPackageOutputFolder).include("*.ap_").first()
            StringBuilder resList = new StringBuilder()
            zipTree(ap_).matching {
                include "res/**"
            }.each { file ->
                resList.append(file.parentFile.name)
                resList.append("_")
                resList.append(file.name)
                resList.append("\n")
            }
            file("${cacheDir}/res_list.txt").write(resList.toString())
        }

        tasks.findByName("minifyReleaseWithR8")?.doLast {
            outputs.files.files.each {
                println it
            }
            copy {
                from outputs.files.files
                include "**/*.txt"
                into cacheDir + "/mapping"
            }
        }
        tasks.findByName("compileReleaseJavaWithJavac")?.doLast {
            file(cacheDir + "/classes").deleteDir()
            outputs.files.files.each { file ->
                if (file.isDirectory()) {
                    copy {
                        from fileTree(file)
                        into cacheDir + "/classes"
                    }
                }
            }
        }
        tasks.findByName("assembleRelease")?.doLast {
            File gradle = file("build.gradle")
            String originalGradle = gradle.text
            try {
                String text = originalGradle
                text = text.replace("com.android.application", "com.android.library")
                        .replace("applicationId", "//applicationId")
                        .replace("shrinkResources", "//shrinkResources")
                        .replace("minifyEnabled", "//minifyEnabled")
                        .replace("zipAlignEnabled", "//zipAlignEnabled")
                        .replace("api", "implementation")
                text += "\nmakeApk2Aar { \n\tmake true \n}"
                gradle.write(text)
                "${rootDir.absolutePath}/gradlew :${project.name}:uploadArchives".execute().waitFor()
            } catch (e) {
                e.printStackTrace()
            }
            gradle.write(originalGradle)
        }
    }
}

def clearEmpty(File... file) {
    file?.each {
        if (it.isDirectory()) {
            def files = it.listFiles()
            clearEmpty(files)
            files = it.listFiles()
            if (files == null || files.size() == 0) {
                it.delete()
            }
        }
    }
}

static def makePublicXml(File publicXml, File idFile) {
    if (idFile.exists()) {
        StringBuilder stringBuilder = new StringBuilder()
        stringBuilder.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
        stringBuilder.append("\n<!-- AUTO-GENERATED FILE.  DO NOT MODIFY -->");
        stringBuilder.append("\n<resources>")
        idFile.readLines().each { text ->
            if (!text.isEmpty() && !text.contains("\$")) {
                stringBuilder.append("\n\t")
                text = text.split(":")[1].split("/")
                def type = text[0]
                text = text[1].split(" = ")
                def name = text[0]
                def id = text[1]
                stringBuilder.append("<public type=\"$type\" name=\"$name\" id=\"$id\" />")
            }
        }
        stringBuilder.append("\n</resources>")
        publicXml.write(stringBuilder.toString())
    }
}
